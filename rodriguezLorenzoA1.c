// FUNCTION DEFINITIONS
#include "givenA1.h"

// Sorting functions prototypes
int compareAscending(const void *a, const void *b);
int compareDescending(const void *a, const void *b);

/*  TASK 1: Read each line of a1Data.txt into animal struct array starting from position 0. 
Each struct element will have animalName, features, and classLabel  */

int readFromFile (char fName [30], struct Animal dataZoo [NUM_SAMPLES]){

    int line_number = 0;


    // Open file in read mode
    FILE * fPtr;  
    fPtr = fopen(fName, "r");   
    
    // File validation
    if (fPtr == NULL){   
        printf("File no work :( ");
        return -1;
    }
    
    // Loop through file to gather info until eof is reached
    while (!feof (fPtr)){
        
        // Get animal name and store at element line_number of struct array
        fscanf(fPtr, "%s", dataZoo[line_number].animalName);   
        
        // Get animal features
        for (int i = 0; i<NUM_FEATURES; i++){
            fscanf(fPtr, "%d", &dataZoo[line_number].features[i]);   // Loops 16 times to get and populate features
        }

        // Get and store class label
        fscanf(fPtr, "%d", &dataZoo[line_number].classLabel);
        
        line_number++;
    }
    
    fclose(fPtr);
    return 1;
}

/* TASK 2: Calculate euclidean distance, hamming distance, and jaccard similarity*/
void distanceFunctions (int vector1 [NUM_FEATURES], int vector2 [NUM_FEATURES], float * euclideanDistance, int * hammingDistance, float * jaccardSimilarity){
    int tempResult = 0;
    float oneMatch = 0.0; 
    float zeroMatch = 0.0;

    *euclideanDistance = 0.0; // Reset value to avoid accumulation issues
    *hammingDistance = 0; // Reset value to avoid accumulation issues

    // Calculate euclidean distance
    for (int i=0; i<NUM_FEATURES; i++){
        tempResult = (vector1[i] - vector2[i]);
        tempResult = tempResult * tempResult;
        *euclideanDistance += tempResult;
    }
    *euclideanDistance = sqrt(*euclideanDistance);
    
    // Calculate hamming distance
    for (int i=0; i<NUM_FEATURES; i++){
        if (vector1[i] != vector2[i]){
            (*hammingDistance)++;
        }
    }

    // Calculate Jaccard Similarity
    for (int i=0; i<NUM_FEATURES; i++){
        if (vector1[i] == 1 && vector2[i] == 1){
            oneMatch++;
        }
        else if (vector1[i] == 0 && vector2[i] == 0){
            zeroMatch++;
        }
    }

    if (NUM_FEATURES - zeroMatch > 0){
        *jaccardSimilarity = oneMatch / (NUM_FEATURES - zeroMatch);
    } 
    else{
        *jaccardSimilarity = 0.0; // for the case where all features are 0
    }

}

// Comparison functions for sorting ascending and descending order. Citation: OpenAI. (2025, January 30). Response generated by ChatGPT
int compareAscending(const void *a, const void *b) {
    float distA = (*(float(*)[2])a)[1];
    float distB = (*(float(*)[2])b)[1];
    return (distA > distB) - (distA < distB); // Equivalent to (distA - distB) for floats
}

int compareDescending(const void *a, const void *b) {
    float distA = (*(float(*)[2])a)[1];
    float distB = (*(float(*)[2])b)[1];
    return (distB > distA) - (distB < distA); // Reverse order
}


/* TASK 3: finds the "k" number of closest neighbors in decreasinf or increaseing order depending on the type
of distance function. The indices of the associated samples are saved in knearestneighbors*/
void findKNearestNeighbors (struct Animal dataZoo [NUM_SAMPLES], int newSample [NUM_FEATURES], int k, int whichDistanceFunction, int kNearestNeighbors [NUM_SAMPLES]){
    
    float distanceArray[NUM_SAMPLES][2]; // Array has 2 spaces one to remember index and one for distance value

    for (int i=0; i<NUM_SAMPLES; i++){  // loop through all sample structs for their features
        int hammingDistance = 0;
        float euclideanDistance = 0.0;
        float jaccardSimilarity = 0.0;
        distanceFunctions(newSample, dataZoo[i].features, &euclideanDistance, &hammingDistance, &jaccardSimilarity); //get diistances for each thing
       
        // Populate distances into a temporary array 
        switch (whichDistanceFunction){
            case 1: 
                distanceArray[i][0]= i;
                distanceArray[i][1]= euclideanDistance;
                break;
            case 2:
                distanceArray[i][0]= i;
                distanceArray[i][1]= hammingDistance;
                break;
            case 3:
                distanceArray[i][0]= i;
                distanceArray[i][1]= jaccardSimilarity;
                break;
        }
    }
    
    // Use sorting functions to sort the unsortedArray
    if (whichDistanceFunction == 1 || whichDistanceFunction == 2){
        qsort(distanceArray, NUM_SAMPLES, sizeof(distanceArray[0]), compareDescending);
    }
    else{
        qsort(distanceArray, NUM_SAMPLES, sizeof(distanceArray[0]), compareAscending);
    }

    // Extract the indices of the k nearest neighbors
    for (int i = 0; i < k; i++) {
        kNearestNeighbors[i] = (int)distanceArray[i][0]; // Store only indices
    }
}

/*TASK 4: predict the class of a given sample*/
int predictClass (struct Animal dataZoo [NUM_SAMPLES], int newSample [NUM_FEATURES], int whichDistanceFunction, int k){
    
    int kNearestNeighbors[NUM_SAMPLES];
    int classFrequency[NUM_CLASSES];   //stores the frequency of each class number (1-7)
    int predictedClass = -1; // The class to return
    int maxFrequency = 0;
    int tempClassLabel = 0;

    // Set class occurance counting array to all zero
    for (int i = 0; i < NUM_CLASSES; i++) {
        classFrequency[i] = 0;
    }

    // Get k nearest neighbors and store indices in an array
    findKNearestNeighbors(dataZoo, newSample, k, whichDistanceFunction, kNearestNeighbors);

    // Count occurrences of each class label in k nearest neighbors
    
    for (int i = 0; i < k; i++) {
        tempClassLabel = dataZoo[kNearestNeighbors[i]-1].classLabel;   // -1 fixes weird indexing issue where it accesses the index after for some reason 
        classFrequency[tempClassLabel]++; // Increment count for this class
    }


    // Find the most frequent class label (use smallest in case of tie)
    for (int i = 0; i < NUM_CLASSES; i++) {
        if (classFrequency[i] > maxFrequency) {
            maxFrequency = classFrequency[i];
            predictedClass = i; // Store the class with highest frequency
        }
    }

    return predictedClass;
    
}

/*TASK 5: output the accuracy of this program when compared with the actual classLabel result*/
float findAccuracy(struct Animal dataZoo [NUM_SAMPLES], int whichDistanceFunction, struct Animal testData [NUM_TEST_DATA], int k){

    int prediction = 0;
    int correctPredictions = 0;
    int predictionsArr[NUM_TEST_DATA]; // Stores preditions, idices match indices of testData.csv
    float accuracy = 0.0;

    // Get predictions for a1Data and store in predictionsArr at corresponding indices
    for (int i=0; i<NUM_TEST_DATA; i++){
        prediction = predictClass(dataZoo, testData[i].features, whichDistanceFunction, k);
        predictionsArr[i] = prediction;
    }

    // Compare predicted classLabel and actual classLabel
    for (int i=0; i<NUM_TEST_DATA; i++){
        if (predictionsArr[i] == testData[i].classLabel){
            correctPredictions++;
        }
    }

    // Calculate accuracy and return it
    accuracy = (float)correctPredictions / NUM_TEST_DATA;
    
    return accuracy;

}
